"use strict";(self.webpackChunkparasola=self.webpackChunkparasola||[]).push([[8590],{25724:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var n=i(74848),r=i(28453);const t={},a="Releases",l={id:"reference/releases",title:"Releases",description:"Releases allow you to distribute bundles to cohorts.",source:"@site/docs/reference/releases.md",sourceDirName:"reference",slug:"/reference/releases",permalink:"/reference/releases",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"reference",previous:{title:"Deployments",permalink:"/reference/deployments"}},o={},c=[{value:"Latest Release",id:"latest-release",level:2},{value:"Availability",id:"availability",level:2},{value:"Graph Traversal",id:"graph-traversal",level:3},{value:"Scheduling",id:"scheduling",level:3},{value:"Phasing",id:"phasing",level:3},{value:"Required Release",id:"required-release",level:2},{value:"Release Resolution",id:"release-resolution",level:2},{value:"Resolution",id:"resolution",level:3},{value:"Static Resolution",id:"static-resolution",level:3},{value:"Dynamic Resolution",id:"dynamic-resolution",level:3}];function d(e){const s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"releases",children:"Releases"}),"\n",(0,n.jsxs)(s.p,{children:["Releases allow you to distribute ",(0,n.jsx)(s.a,{href:"/reference/bundles",children:"bundles"})," to ",(0,n.jsx)(s.a,{href:"/reference/cohorts",children:"cohorts"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"Each release belongs to an individual cohort."}),"\n",(0,n.jsx)(s.h2,{id:"latest-release",children:"Latest Release"}),"\n",(0,n.jsxs)(s.p,{children:['When creating a release you may create it as the "latest release" or not. The latest release refers to the release within the cohort whose ',(0,n.jsx)(s.code,{children:"next_release_prn"})," is ",(0,n.jsx)(s.code,{children:"null"}),". It does not refer to the most recently inserted release. Only one release within a cohort at any given time may be the latest release."]}),"\n",(0,n.jsx)(s.p,{children:"The latest release of a cohort is special in that it is the only release within a cohort that is allowed to limit its availability via scheduling and phasing."}),"\n",(0,n.jsx)(s.admonition,{type:"info",children:(0,n.jsx)(s.p,{children:"You cannot create a new latest release while the current latest release is scheduled or phased."})}),"\n",(0,n.jsx)(s.h2,{id:"availability",children:"Availability"}),"\n",(0,n.jsx)(s.p,{children:"The availability of a release, the ability for devices to resolve it when checking for updates, is dictated by three concepts: graph traversal, scheduling, and phasing."}),"\n",(0,n.jsx)(s.h3,{id:"graph-traversal",children:"Graph Traversal"}),"\n",(0,n.jsx)(s.p,{children:"When creating releases within a cohort, they will form a release graph."}),"\n",(0,n.jsx)(s.p,{children:"For example."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"R4--------\x3eR5---\\\n                 \\\nR1---\\            |---\x3eR6\n      |---\x3eR2----/\nR3---/\n"})}),"\n",(0,n.jsx)(s.p,{children:"In order for a release on the graph to be relevant to you, it must be between your current release, and the latest release."}),"\n",(0,n.jsx)(s.p,{children:"For example, if your current release was R4, then R5 is available with respect to graph traversal, but R2 is not. Keep in mind this is an instantaneous evaluation at it would be possible for example for the device to be factory reset to R1, at which point R2 would be traversible."}),"\n",(0,n.jsx)(s.h3,{id:"scheduling",children:"Scheduling"}),"\n",(0,n.jsx)(s.p,{children:"The latest release in a cohort can be scheduled to become available immediately, or a date in the future can be choosen. This allows you to stage a release ahead of time and have it become available automatically at a specific time."}),"\n",(0,n.jsx)(s.admonition,{type:"tip",children:(0,n.jsx)(s.p,{children:'When a release has been created, but its schedule date has not occurred yet, the release is said to be "scheduled". Keep in mind you cannot create a new latest release if the current latest release is scheduled.'})}),"\n",(0,n.jsx)(s.p,{children:"A release ceases to be scheduled once its schedule date has passed."}),"\n",(0,n.jsx)(s.h3,{id:"phasing",children:"Phasing"}),"\n",(0,n.jsx)(s.p,{children:"The latest release in a cohort can be made available gradually by configuring its phase value. This can be used to limit how many devices are allowed to take the release to either a percent of the cohort, or an absolute threshold of devices. Once the limit is met, the release is unavailable until the phase value is increased."}),"\n",(0,n.jsx)(s.admonition,{type:"tip",children:(0,n.jsx)(s.p,{children:'When a release\'s phase value is not 100%, the release is said to be "phased". Keep in mind you cannot create a new latest release if the current latest release is phased.'})}),"\n",(0,n.jsx)(s.p,{children:"A release ceases to be phased once its phase value is 100%."}),"\n",(0,n.jsx)(s.h2,{id:"required-release",children:"Required Release"}),"\n",(0,n.jsxs)(s.p,{children:["A release can be configured with its ",(0,n.jsx)(s.code,{children:"required"})," field set to ",(0,n.jsx)(s.code,{children:"true"})," or ",(0,n.jsx)(s.code,{children:"false"}),", and this field can be changed at any time."]}),"\n",(0,n.jsxs)(s.p,{children:["When ",(0,n.jsx)(s.code,{children:"true"}),", devices that encounter this release are required to pass through it."]}),"\n",(0,n.jsxs)(s.p,{children:["When ",(0,n.jsx)(s.code,{children:"false"}),", device can potentially skip the release if there is a newer subsequent release available."]}),"\n",(0,n.jsx)(s.p,{children:"For example:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"R4--------\x3eR5---\\\n                 \\\nR1---\\            |---\x3eR6\n      |---\x3eR2----/\nR3---/\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Lets say that ",(0,n.jsx)(s.code,{children:"R2"})," above is the only required release. If a device was on ",(0,n.jsx)(s.code,{children:"R1"}),", it would have to update to ",(0,n.jsx)(s.code,{children:"R2"})," first, even though ",(0,n.jsx)(s.code,{children:"R6"})," is already available. Whereas if a device was on ",(0,n.jsx)(s.code,{children:"R4"}),", it could update directly to ",(0,n.jsx)(s.code,{children:"R6"}),", because ",(0,n.jsx)(s.code,{children:"R5"})," is not required."]}),"\n",(0,n.jsx)(s.h2,{id:"release-resolution",children:"Release Resolution"}),"\n",(0,n.jsxs)(s.p,{children:["When a device executes a Device API ",(0,n.jsx)(s.a,{href:"/device-api#devices/operation/get-update",children:"get-update"})," request, Peridio performs release resolution. Release resolution is the process of determing if there is another release, referred to as the target release, the device can update to. To make this determination, Peridio must have some idea of determining where your device currently fits into it's cohort's release graph, since where a device currently is will determine where it needs to go. A cohort's release graph forms an ",(0,n.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Arborescence_(graph_theory)",children:"anti-arborescence"}),". In other words, releases may point to exactly one next release, a release may be pointed to by zero to many releases, all releases eventually converge to a single ",(0,n.jsx)(s.a,{href:"#latest-release",children:"latest release"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"For example:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"R4--------\x3eR5---\\\n                 \\\nR1---\\            |---\x3eR6\n      |---\x3eR2----/\nR3---/\n"})}),"\n",(0,n.jsx)(s.h3,{id:"resolution",children:"Resolution"}),"\n",(0,n.jsxs)(s.p,{children:["Peridio will first attempt to determine your devices current release via ",(0,n.jsx)(s.a,{href:"#static-resolution",children:"static resolution"})," if possible, and ",(0,n.jsx)(s.a,{href:"#dynamic-resolution",children:"dynamic"})," resolution if that fails."]}),"\n",(0,n.jsx)(s.admonition,{title:"prefer static resolution",type:"info",children:(0,n.jsx)(s.p,{children:"Whenever possible it is recommended to use static resolution over dynamic resolution as the former is easier to reason about and more efficent to perform. However, when required, dynamic resolution can be used in situations where your device does not or can not know the PRN of its current release, yet it still wishes to deterministically update according to its cohort's release graph."})}),"\n",(0,n.jsx)(s.h3,{id:"static-resolution",children:"Static Resolution"}),"\n",(0,n.jsxs)(s.p,{children:["Static resolution uses the ",(0,n.jsx)(s.code,{children:"peridio-release-prn"})," header to define a prn that is representative of the device's current release. If it successfully identifies a release in the device's cohort, release resolution will consider it the device's current release and continue with resolution:"]}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:["checks if there is a next release.","\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:"If yes, go to #2."}),"\n",(0,n.jsxs)(s.li,{children:["If no, release resolution completes with no target release with a reason of ",(0,n.jsx)(s.code,{children:"no_update"}),"."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["checks if the release is required.","\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:["If yes, release resolution completes with a target release with a reason of ",(0,n.jsx)(s.code,{children:"update"}),"."]}),"\n",(0,n.jsx)(s.li,{children:"If no, go to #3."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["checks if there is a next release.","\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:"If yes, go to #2."}),"\n",(0,n.jsxs)(s.li,{children:["If no, release resolution completes with a target release with a reason of ",(0,n.jsx)(s.code,{children:"update"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Peridio will recurse between #3.1 and #2 to skip as many not-required releases as possible."}),"\n",(0,n.jsx)(s.h3,{id:"dynamic-resolution",children:"Dynamic Resolution"}),"\n",(0,n.jsxs)(s.p,{children:["Dynamic resolution uses the ",(0,n.jsx)(s.code,{children:"peridio-release-version"})," header to define a semantic version that is representative of the device's current release."]}),"\n",(0,n.jsxs)(s.p,{children:["Peridio then finds all releases in the device's cohort that have specified both a ",(0,n.jsx)(s.code,{children:"version"})," and ",(0,n.jsx)(s.code,{children:"version_requirement"}),". The found releases are filtered for those whose ",(0,n.jsx)(s.code,{children:"version_requirement"})," is satisfied by the header-supplied version. From the filtered results, the release with the lowest semantic ",(0,n.jsx)(s.code,{children:"version"}),' is selected as the "dynamic entry point". Peridio will then consider your devices current release to be an imaginary release whose next release is the dynamic entry point and continue with resolution:']}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:["checks if there is a next release.","\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:"There always will be because it will be the dynamic entry point, go to #2."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["checks if the release is required.","\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:["If yes, release resolution completes with a target release with a reason of ",(0,n.jsx)(s.code,{children:"update"}),"."]}),"\n",(0,n.jsx)(s.li,{children:"If no, go to #3."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["checks if there is a next release.","\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:"If yes, go to #2."}),"\n",(0,n.jsxs)(s.li,{children:["If no, release resolution completes with a target release with a reason of ",(0,n.jsx)(s.code,{children:"update"}),"."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,s,i)=>{i.d(s,{R:()=>a,x:()=>l});var n=i(96540);const r={},t=n.createContext(r);function a(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);
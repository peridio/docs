"use strict";(self.webpackChunkparasola=self.webpackChunkparasola||[]).push([[9349],{47669:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(74848),t=n(28453);const r={title:"Firmware"},s=void 0,l={id:"platform/reference/firmware",title:"Firmware",description:"This functionality has been superceded by artifacts, artifact versions, and binaries.",source:"@site/docs/platform/reference/firmware.md",sourceDirName:"platform/reference",slug:"/platform/reference/firmware",permalink:"/platform/reference/firmware",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Firmware"},sidebar:"platform",previous:{title:"Signing Keys",permalink:"/platform/reference/signing-keys"},next:{title:"Webhooks",permalink:"/platform/reference/webhooks"}},o={},d=[{value:"Firmware Installation",id:"firmware-installation",level:2},{value:"Self-Managed",id:"self-managed",level:3},{value:"Peridio Managed",id:"peridio-managed",level:3},{value:"Firmware File Requirements",id:"firmware-file-requirements",level:2},{value:"Time to Live (TTL)",id:"time-to-live-ttl",level:2},{value:"Example",id:"example",level:3},{value:"Delta Updates",id:"delta-updates",level:2},{value:"Self-Managed",id:"self-managed-1",level:3},{value:"Peridio-Managed",id:"peridio-managed-1",level:3}];function c(e){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.admonition,{title:"Legacy",type:"info",children:(0,a.jsxs)(i.p,{children:["This functionality has been superceded by ",(0,a.jsx)(i.a,{href:"artifacts",children:"artifacts"}),", ",(0,a.jsx)(i.a,{href:"artifact-versions",children:"artifact versions"}),", and ",(0,a.jsx)(i.a,{href:"binaries",children:"binaries"}),"."]})}),"\n",(0,a.jsx)(i.p,{children:"Firmware are the data you wish to distribute to devices."}),"\n",(0,a.jsxs)(i.p,{children:["Peridio requires the use of ",(0,a.jsx)(i.a,{href:"https://github.com/fwup-home/fwup",children:"fwup"})," archives as the packaging format for firmware. This means the binaries you upload to Peridio and the binaries your devices will download from Peridio are fwup archives. The contents of an archive are up to you; ranging from no files, to 1 file, to ",(0,a.jsx)(i.code,{children:"n"})," files. They are capable of packaging an arbitrary stringy metadata payload. Note that fwup archives themselves are ZIP archives and can be interacted with as such."]}),"\n",(0,a.jsxs)(i.p,{children:["To learn more about how to use firmware, see the ",(0,a.jsx)(i.a,{href:"/platform/guides/creating-firmware",children:"creating firmware"})," guide."]}),"\n",(0,a.jsx)(i.h2,{id:"firmware-installation",children:"Firmware Installation"}),"\n",(0,a.jsx)(i.p,{children:"It is possible to perform firmware installation with Peridio in a self-managed or Peridio-managed fashion."}),"\n",(0,a.jsx)(i.h3,{id:"self-managed",children:"Self-Managed"}),"\n",(0,a.jsx)(i.p,{children:"This approach means you are responsible for all device-side interactions with Peridio as well as executing any device-side operation thereafter. This buys absolute flexibility at the cost of owning the complexity yourself."}),"\n",(0,a.jsx)(i.h3,{id:"peridio-managed",children:"Peridio Managed"}),"\n",(0,a.jsxs)(i.p,{children:["The ",(0,a.jsx)(i.a,{href:"/platform/agent",children:"Peridio Agent"})," can be used to check for updates, stream their download (including automated delta updates), verify their signature, and install their contents. This buys efficient simplicity at the cost of flexibility."]}),"\n",(0,a.jsx)(i.h2,{id:"firmware-file-requirements",children:"Firmware File Requirements"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Firmware files are signed fwup archives."}),"\n",(0,a.jsxs)(i.li,{children:["The following ",(0,a.jsx)(i.a,{href:"https://github.com/fwup-home/fwup#global-scope",children:"global scope"})," options must be specified:","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"meta-architecture"})," must have a value. Informational."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"meta-platform"})," must have a value. Informational."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"meta-product"})," must exactly match the name of a ",(0,a.jsx)(i.a,{href:"/platform/reference/products",children:"product"})," in your ",(0,a.jsx)(i.a,{href:"/platform/reference/organizations",children:"organization"}),". Defines the product within which the firmware will be scoped."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"meta-version"})," must be a valid ",(0,a.jsx)(i.a,{href:"https://semver.org/spec/v2.0.0.html",children:"semantic version"}),". Defines the version of the firmware."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"time-to-live-ttl",children:"Time to Live (TTL)"}),"\n",(0,a.jsxs)(i.p,{children:["Firmware can be configured on a per-firmware basis to be deleted automatically after a set amount of seconds by configuring their ",(0,a.jsx)(i.code,{children:"ttl"})," field. Firmware associated with a deployment will never be automatically deleted. Dissassociating a firmware with a configured TTL from all deployments will cause the TTL to begin counting down again from its maximum value."]}),"\n",(0,a.jsx)(i.h3,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["Firmware (A) is created with ",(0,a.jsx)(i.code,{children:"ttl: 60"})," and is associated with zero deployments.","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Firmware (A)'s TTL begins counting down and it will be automatically deleted once it runs out."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["Firmware (A) is associated with deployment (B).","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Firmware (A)'s TTL is ignored and it will not be automatically deleted."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["Firmware (A) is associated with deployment (C).","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Firmware (A) is now associated with two deployments, its TTL continues to be ignored and it still will not be automatically deleted."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["Deployment (B) is deleted.","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Firmware (A) is still associated with at least one deployment, its TTL continues to be ignored and it still will not be automatically deleted."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["Deployment (C) is deleted.","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["Firmware (A) is associated with zero deployments, its TTL begins counting down from its maximum value of ",(0,a.jsx)(i.code,{children:"60"})," and it will be automatically deleted once it runs out."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"delta-updates",children:"Delta Updates"}),"\n",(0,a.jsx)(i.p,{children:"It is possible to ship delta updates with Peridio in a self-managed or Peridio-managed fashion."}),"\n",(0,a.jsx)(i.h3,{id:"self-managed-1",children:"Self-Managed"}),"\n",(0,a.jsx)(i.p,{children:"This approach yields the greatest flexibility, but comes at the cost of complexity. It would mean you would be responsible for:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:"Generating patch files yourself before submitting them as firmware to Peridio."}),"\n",(0,a.jsx)(i.li,{children:"Ensuring you orchestrate your deployments in such a manner as to serve patch files to the correct devices."}),"\n",(0,a.jsx)(i.li,{children:"Write the device code to apply the patch files."}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"Note that with this approach you would not actually enable delta updates features in Peridio (check boxes in the Web Console nor fields in the API/CLI), as that is used only in the Peridio-Managed case."}),"\n",(0,a.jsx)(i.h3,{id:"peridio-managed-1",children:"Peridio-Managed"}),"\n",(0,a.jsx)(i.p,{children:"This approach has Peridio automatically generate, serve, and apply patch files for you, but comes at the cost of flexibility and customization. In particular, the following requirements are imposed:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Delta updates are enabled on a per deployment basis."}),"\n",(0,a.jsx)(i.li,{children:"fwup must be used to apply updates, and it must be version 1.6.0 or greater."}),"\n",(0,a.jsxs)(i.li,{children:["While your fwup conf and archives may include arbitrary contents, only a file-resource named ",(0,a.jsx)(i.code,{children:"rootfs.img"})," will be diffed/patched."]}),"\n",(0,a.jsxs)(i.li,{children:["Your fwup conf's tasks to write the ",(0,a.jsx)(i.code,{children:"rootfs.img"})," must use the ",(0,a.jsx)(i.code,{children:"delta-source-raw-offset"}),", ",(0,a.jsx)(i.code,{children:"delta-source-raw-count"}),", and ",(0,a.jsx)(i.code,{children:"raw_write"})," settings.","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"If you wish to also use an A/B update scheme, the tasks may for example resemble the following:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"task upgrade.a {\n    on-resource rootfs.img {\n        delta-source-raw-offset=${ROOTFS_B_PART_OFFSET}\n        delta-source-raw-count=${ROOTFS_B_PART_COUNT}\n        raw_write(${ROOTFS_A_PART_OFFSET})\n    }\n}\ntask upgrade.b {\n    on-resource rootfs.img {\n        delta-source-raw-offset=${ROOTFS_A_PART_OFFSET}\n        delta-source-raw-count=${ROOTFS_A_PART_COUNT}\n        raw_write(${ROOTFS_B_PART_OFFSET})\n    }\n}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>l});var a=n(96540);const t={},r=a.createContext(t);function s(e){const i=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(r.Provider,{value:i},e.children)}}}]);
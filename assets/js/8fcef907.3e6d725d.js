"use strict";(self.webpackChunkperidio_docs=self.webpackChunkperidio_docs||[]).push([[1197],{73150:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>n,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>h});var i=s(74848),r=s(28453);const a={},n="Releases",l={id:"platform/reference/releases",title:"Releases",description:"Releases allow you to distribute bundles to cohorts. Each release is associated with exactly one cohort. Within a cohort, releases form a graph.",source:"@site/docs/platform/reference/releases.md",sourceDirName:"platform/reference",slug:"/platform/reference/releases",permalink:"/platform/reference/releases",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"platform",previous:{title:"Deployments",permalink:"/platform/reference/deployments"},next:{title:"Tunnels",permalink:"/platform/reference/tunnels"}},o={},h=[{value:"Latest Release",id:"latest-release",level:2},{value:"Rollout",id:"rollout",level:2},{value:"Scheduling",id:"scheduling",level:3},{value:"Phasing",id:"phasing",level:3},{value:"Tags",id:"tags",level:4},{value:"Numeric",id:"numeric",level:4},{value:"Release Resolution",id:"release-resolution",level:2},{value:"Graph Traversal",id:"graph-traversal",level:3},{value:"Resolution",id:"resolution",level:3},{value:"Static Resolution",id:"static-resolution",level:4},{value:"Dynamic Resolution",id:"dynamic-resolution",level:4},{value:"Skip Unrequired Releases",id:"skip-unrequired-releases",level:4},{value:"Activity Diagram",id:"activity-diagram",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"releases",children:"Releases"}),"\n",(0,i.jsxs)(t.p,{children:["Releases allow you to distribute ",(0,i.jsx)(t.a,{href:"/platform/reference/bundles",children:"bundles"})," to ",(0,i.jsx)(t.a,{href:"/platform/reference/cohorts",children:"cohorts"}),". Each release is associated with exactly one cohort. Within a cohort, releases form a ",(0,i.jsx)(t.a,{href:"/platform/reference/cohorts#release-graph",children:"graph"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"latest-release",children:"Latest Release"}),"\n",(0,i.jsxs)(t.p,{children:["The latest release in a graph is the one whose ",(0,i.jsx)(t.code,{children:"next_release_prn"})," is ",(0,i.jsx)(t.code,{children:"null"}),". A graph only ever has at most one latest release at any given time. The latest release of a graph is special in that it is the only release within a graph that is allowed to limit its ",(0,i.jsx)(t.a,{href:"#rollout",children:"rollout"})," via scheduling and phasing."]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["You cannot create a new latest release while the current latest release is ",(0,i.jsx)(t.a,{href:"#scheduling",children:"scheduled"})," or ",(0,i.jsx)(t.a,{href:"#phasing",children:"phased"}),"."]})}),"\n",(0,i.jsx)(t.h2,{id:"rollout",children:"Rollout"}),"\n",(0,i.jsx)(t.p,{children:"A graph's latest release can schedule or limit its availability in pursuit of more precisely or gradually rolling out a bundle."}),"\n",(0,i.jsx)(t.h3,{id:"scheduling",children:"Scheduling"}),"\n",(0,i.jsx)(t.p,{children:"The latest release in a graph can be scheduled to become available immediately, or a date in the future can be choosen. This allows you to stage a release ahead of time and have it become available automatically at a specific time."}),"\n",(0,i.jsx)(t.p,{children:"A release ceases to be scheduled once its schedule date has passed."}),"\n",(0,i.jsx)(t.h3,{id:"phasing",children:"Phasing"}),"\n",(0,i.jsx)(t.p,{children:"The latest release in a graph can be made available gradually by configuring its phase mode. This can be used to limit how many devices are allowed to take the release either by tags or numerically."}),"\n",(0,i.jsx)(t.p,{children:"A release ceases to be phased once its phase mode is numeric and its phase value is 100%."}),"\n",(0,i.jsx)(t.h4,{id:"tags",children:"Tags"}),"\n",(0,i.jsx)(t.p,{children:"Only devices within the cohort who have any of the specified phase tags are able to update to the latest release."}),"\n",(0,i.jsx)(t.h4,{id:"numeric",children:"Numeric"}),"\n",(0,i.jsx)(t.p,{children:"Limit the amount of devices that are able to update to the latest release by configuring the phase value:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["When a decimal in ",(0,i.jsx)(t.code,{children:"[0.0, 1.0]"}),", it is treated as a percent, e.g., to allow 20% of the cohort to update, you would specifiy 0.2."]}),"\n",(0,i.jsxs)(t.li,{children:["When an integer ",(0,i.jsx)(t.code,{children:">= 2"}),", it is treated as an absolute device count, e.g., to allow 40 of the cohort's devices to update, you would specifiy 40."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"release-resolution",children:"Release Resolution"}),"\n",(0,i.jsxs)(t.p,{children:["When a device executes a Device API ",(0,i.jsx)(t.a,{href:"/device-api#devices/operation/get-update",children:"get-update"})," request, Peridio performs release resolution. Release resolution is the process of determing if there is another release, referred to as the target release, the device can update to. To make this determination, Peridio must have some idea of determining where your device currently fits into it's cohort's release graph, since where a device currently is will determine where it needs to go."]}),"\n",(0,i.jsx)(t.h3,{id:"graph-traversal",children:"Graph Traversal"}),"\n",(0,i.jsx)(t.p,{children:"In order for a release in the graph to be relevant to you, it must be between your current release, and the latest release."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"R0--------\x3eR1---\\\n                 \\\nR2---\\            |---\x3eR5\n      |---\x3eR4----/\nR3---/\n"})}),"\n",(0,i.jsx)(t.p,{children:"For example, if your current release was R0, then R1 is available with respect to graph traversal, but R2 is not."}),"\n",(0,i.jsx)(t.h3,{id:"resolution",children:"Resolution"}),"\n",(0,i.jsxs)(t.p,{children:["Peridio must determine the device's current position in its cohort's release graph. Peridio will first attempt to determine this via ",(0,i.jsx)(t.a,{href:"#static-resolution",children:"static resolution"}),", but can optionally fallback to ",(0,i.jsx)(t.a,{href:"#dynamic-resolution",children:"dynamic resolution"}),"."]}),"\n",(0,i.jsx)(t.h4,{id:"static-resolution",children:"Static Resolution"}),"\n",(0,i.jsxs)(t.p,{children:["Static resolution uses the ",(0,i.jsx)(t.code,{children:"peridio-release-prn"})," header to supply its current release's PRN. If it successfully identifies a release in the device's cohort, then the current release is known. If the current release has a next release, then resolution continues with its next release. If not, then resolution falls back to dynamic resolution if possible. If not, then resolution completes with no target release."]}),"\n",(0,i.jsx)(t.h4,{id:"dynamic-resolution",children:"Dynamic Resolution"}),"\n",(0,i.jsxs)(t.p,{children:["Dynamic resolution uses the ",(0,i.jsx)(t.code,{children:"peridio-release-version"})," header to supply a ",(0,i.jsx)(t.a,{href:"https://semver.org/",children:"SemVer"})," version that is representative of the device's current release so that release version requirements can be leveraged to dynamically enter the release graph. If the cohort contains releases with a ",(0,i.jsx)(t.code,{children:"version"})," and ",(0,i.jsx)(t.code,{children:"version_requirement"})," specified, where the header supplied version satisfies the version requirements, then of those releases the one with the lowest version is considered the next release and resolution continues."]}),"\n",(0,i.jsx)(t.admonition,{title:"prefer static resolution",type:"info",children:(0,i.jsx)(t.p,{children:"Static resolution should be used whenever possible as it is easier to reason about and more efficent to perform than dynamic resolution. However, when required, dynamic resolution can be used in situations where your device does not or can not know the PRN of its current release, yet it still wishes to deterministically update according to its cohort's release graph. For example, this can be useful when moving devices across cohorts."})}),"\n",(0,i.jsx)(t.h4,{id:"skip-unrequired-releases",children:"Skip Unrequired Releases"}),"\n",(0,i.jsxs)(t.p,{children:["If static or dynamic resolution identify a next release we enter into a cycle where we attempt to skip as many releases in the graph as possible, only stopping if we encounter a required release or the latest release. If we encounter a required release, then resolution completes with it as the target release. If we encounter the latest release, then the release we just walked that points to it is considered the candidate release and we ",(0,i.jsx)(t.a,{href:"#rollout",children:"evaluate the rollout"})," of the latest release to determine if we can update to it or not right now. If we can, then resolution completes with the latest release as the target release. If not, then resolutions completes with the candidate release as the target release."]}),"\n",(0,i.jsx)(t.h3,{id:"activity-diagram",children:"Activity Diagram"}),"\n",(0,i.jsx)(t.p,{children:"Below is a diagram that specifies how release resolution works in depth."}),"\n",(0,i.jsx)(t.admonition,{title:"the bigger picture",type:"tip",children:(0,i.jsx)(t.p,{children:'To best expand the image, right click it and "Open Image in New Tab". From there you can more easily pan and zoom.'})}),"\n",(0,i.jsx)("img",{src:"/img/release-resolution.png",width:"auto"})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>n,x:()=>l});var i=s(96540);const r={},a=i.createContext(r);function n(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);